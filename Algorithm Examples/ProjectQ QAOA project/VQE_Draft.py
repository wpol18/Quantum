## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  Variational Quantum Eigensolver
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


from projectq import MainEngine
from projectq.ops import QubitOperator, Measure, All, Rx, Ry

import numpy as np
from collections import Counter
import time

class VQE(object):

    def __init__(self):
        ''' To-do... '''
        
        
    def run(self, ansatz, hamiltonian, shots = 10000, eng = None):
        ''' Main function. '''
        pass

    
    def expectation(self, state_prep, hamiltonian, shots, eng):
        
        """
        Compute the expecation value of a given hamiltonian over the distribution
        generated by some given state_prep function.
        
        :param state_prep: The state preparation function used to calculate the
        expectation value.
        
        :param hamiltonian: QubitOperator representing the hamiltonian of which
        to calculate the expectation value.
        
        :param shots: The number of samples used to calculate the expectation value.
        
        :param eng: The MainEngine object we will be making calls to.
        
        :return: A float representing the expectation value of hamiltonian given
        the state prepared by state_prep.
        
        """
        
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Check types
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if not isinstance(hamiltonian, QubitOperator):
            raise TypeError('Argument `hamiltonian` provided to expectation must be a QubitOperator.')
        
        if not isinstance(shots, int):
            raise TypeError('Argument `shots` provided to expectation must be an integer.')

        if shots <= 0:
            raise ValueError("samples variable must be a positive integer")

        eng = eng or MainEngine()
        if not isinstance(eng, MainEngine):
            raise TypeError('Argument `eng` provided to expectation_naive must be a MainEngine.')



        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Get expectation, term by term
        #
        # Hamiltonians are made up of Pauli gates: Is, Xs, Ys, and Zs
        #
        # Look through terms of Hamiltonian and add some correcting rotations to 
        # throw specific qubits back into the Z-basis (the native measuring basis)
        # when term is an X or a Y
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        expectation_total = 0
        for term, coefficient in hamiltonian.terms.items():

            rotations = []
            marked_qubits = []

            if term == ():
                expectation_total += coefficient

            for index, gate in term:
                marked_qubits.append(index)
                if gate == 'X':
                    rotations.append((Ry(-np.pi/2), index))
                elif gate == 'Y':
                    rotations.append((Rx(np.pi/2), index))



        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # run through circuit `shots` number of times
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            results = []
            for _ in range(shots):

            # Prepare state by instantiating state_prep
                q = state_prep(eng)
                
            # Apply correction rotations for 'X' and 'Y' gates in Hamiltonian
                for rotation, qubit_index in reversed(rotations):
                    rotation | q[qubit_index]

            # Measure and flush engine
                All(Measure) | q
                eng.flush()

            # Append each bitstring resulting from measurement to results
                results.append([int(qubit) for qubit in q])




        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Convert results into a dictionary with bitstring tuples as keys,
        # number of occurences as values
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            bitstring_tuples = list(map(tuple, results))
            freq = Counter(bitstring_tuples)

        

        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Add or subtract from expectation value depending on number of 1's in bitstring
        # If number of 1s is odd, subtract from total expectation value. If even, add.
        # Reasoning is that reading out a |0 > corresponds to an eigenvalue of +1, and
        # reading out a |1 > corresponds to an eigenvalue of -1. We're multiplying the
        # eigenvalues of each individual term, so if we had an odd number of terms we'd
        # have an overall -1 multiplying the entire state
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            expectation = 0
            for bitstring, count in freq.items():
                number_of_1s = 0
                for b, bit in enumerate(bitstring):
                    if bit == 1 and b in marked_qubits:
                        number_of_1s +=1
                if number_of_1s % 2 == 0:
                    expectation += coefficient*float(count)/shots
                else:
                    expectation -= coefficient*float(count)/shots

            expectation_total += expectation
        

        return expectation_total.real

        
    



## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##             Test
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

if __name__ == "__main__":


    from projectq.ops import H, X
    import time
    
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # First define a state_prep function. This should take our initialized state from
    # |0 0 > ----> |+ 1 >
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    def state_prep(eng):
        qureg = eng.allocate_qureg(2)
        H | qureg[0]
        X | qureg[1]
        return qureg

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Now let's create some example Hamiltonians.
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ham_example1 = QubitOperator('X0 Z1', 3.0)
    ham_example2 = QubitOperator('X0 Z1', 3.0) + \
                           QubitOperator('Y1') + \
                           QubitOperator('Z1', 2)


    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Let's just create an engine instance
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    eng_example = MainEngine()


    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # We should find expectation value to be ~ -3.0 if we use ham_example1,
    # and ~ -5.0 if we use ham_example2
    # Let's check it out:
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    start = time.time()
    exp = VQE().expectation(state_prep, ham_example2, 1000, eng_example)
    end = time.time()
    print('\nExpectation (calculated in', end - start, 'seconds):\n', exp, '\n')



