## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  Variational QUantum Eigensolver
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


from projectq import MainEngine
from projectq.ops import QubitOperator, Measure, All, Rx, Ry, H, X

import numpy as np
from collections import Counter

class VQE(object):

    def __init__(self):
        ''' To-do... '''
        
        
    def run(self, ansatz, hamiltonian, shots = 10000, eng = None):
        ''' Main function. '''
        pass

    @staticmethod
    def expectation(state_prep,
                    hamiltonian: QubitOperator,
                    shots: int,
                    eng: MainEngine) -> float:
        
        """
        Compute the expecation value of a given hamiltonian over the distribution
        generated by some given state_prep function.
        
        :param state_prep: The state preparation function used to calculate the
        expectation value.
        
        :param hamiltonian: QubitOperator representing the hamiltonian of which
        to calculate the expectation value.
        
        :param shots: The number of samples used to calculate the expectation value.
        
        :param eng: The MainEngine object we will be making calls to.
        
        :return: A float representing the expectation value of hamiltonian given
        the state prepared by state_prep.
        
        """
        
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Check types
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if not isinstance(hamiltonian, QubitOperator):
            raise TypeError('Argument `hamiltonian` provided to expectation must be a QubitOperator.')
        
        if not isinstance(shots, int):
            raise TypeError('Argument `shots` provided to expectation must be an integer.')

        if shots <= 0:
            raise ValueError("samples variable must be a positive integer")

        eng = eng or MainEngine()
        if not isinstance(eng, MainEngine):
            raise TypeError('Argument `eng` provided to expectation_naive must be a MainEngine.')



        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Look through terms of Hamiltonian and some correcting rotations to 
        # throw specific qubits back into the Z-basis (the native measuring basis)
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        rotations = []
        marked_qubits = []
        for term, coefficient in hamiltonian.terms.items():
            #rotations = []
            #qubits_to_measure = []
            #marked_qubits = []

            for index, gate in term:
                if gate == 'X':
                    rotations.append(Ry(-np.pi/2))
                    marked_qubits.append(index)
                elif gate == 'Y':
                    rotations.append(Rx(np.pi/2))
                    marked_qubits.append(index)



        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # run through circuit `shots` number of times
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        results = []
        for _ in range(shots):

            # Prepare state by instantiating requisite objects and applying state_prep
            q = eng.allocate_qureg(2)
            state_prep(q)

            # Apply correction rotations for 'X' and 'Y' gates in Hamiltonian
            for rotation, qubit_index in zip(rotations, marked_qubits):
                rotation | q[qubit_index]

            # Measure and flush engine
            All(Measure) | q
            eng.flush()

            # Append each bitstring resulting from measurement to results
            results.append([int(qubit) for qubit in q])




        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Convert results into a dictionary with bitstring tuples as keys,
        # number of occurences as values
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        bitstring_tuples = list(map(tuple, results))
        freq = Counter(bitstring_tuples)

        

        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Add or subtract from expectation value depending on number of 1's in bitstring
        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        expectation = 0
        for bitstring, count in freq.items():
            number_of_1s = 0
            for bit in bitstring:
                if bit == 1:
                    number_of_1s +=1
            if number_of_1s % 2 == 0:
                expectation += float(count)/shots
            else:
                expectation -= float(count)/shots

        return expectation
    



## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##             Test
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

if __name__ == "__main__":


    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # First define a state_prep function. This should take our initialized state from
    # |0 0 > ----> |+ 1 >
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    def state_prep(qureg):
        H | qureg[0]
        X | qureg[1]

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Now let's create some example Hamiltonian. We'll use the Hamiltonian
    # X*Z, where Z acts on the first qubit, Z acts on the second qubit
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    hamiltonian_example = QubitOperator('X0 Z1')


    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Let's just create an engine instance
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    eng_example = MainEngine()


    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # All of the above should result in an expectation value of -1.0. Let's check it out:
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    exp = VQE.expectation(state_prep, hamiltonian_example, 1000, eng_example)
    print('Expectation: ', exp)

    assert exp == -1.0
